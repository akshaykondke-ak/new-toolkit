
Pentoolkit Project Structure & Flow - Team Presentation Guide

Pentoolkit Project Structure & Flow - Team Presentation Guide
1. Project Overview & Installation
What is Pentoolkit?
Purpose: Automated penetration testing toolkit for web security assessments
Language: Python 3.10+
Architecture: Modular CLI tool with multiple scanning engines
Version: 0.2.0
Installation Steps
# 1. Clone the repository
git clone https://github.com/your-repo/new-toolkit
cd new-toolkit

# 2. Create virtual environment
python -m venv venv
source venv/bin/activate  # Linux/Mac
# or: venv\Scripts\activate  # Windows

# 3. Install in development mode
pip install -e ./pentoolkit

# 4. Create configuration
pentoolkit config create

# 5. Verify installation
pentoolkit --help
Dependencies
typer: CLI framework with automatic help generation
rich: Beautiful terminal output and progress bars
python-nmap: Python wrapper for Nmap
PyYAML: Configuration file parsing
requests: HTTP operations
2. Project Structure Deep Dive
pentoolkit/
├── src/pentoolkit/
│   ├── __init__.py
│   ├── cli.py              # Main CLI interface (Typer)
│   ├── main.py             # Scan orchestrator
│   ├── config.yaml         # Configuration file
│   ├── modules/            # Individual scanners
│   │   ├── nmap_scanner.py     # Port scanning
│   │   ├── ssl_scanner.py      # SSL/TLS analysis
│   │   ├── web_recon.py        # Directory/file discovery
│   │   ├── whois_lookup.py     # Domain information
│   │   └── waf_detector.py     # Web Application Firewall detection
│   ├── utils/              # Core utilities
│   │   ├── config.py           # Configuration management
│   │   ├── report.py           # Report generation
│   │   └── helpers.py          # Common functions
│   └── reports/            # Generated output files
├── pyproject.toml          # Project metadata & dependencies
├── README.md
└── test_run.py            # Manual testing script
3. Configuration System
Configuration Files
Location: ./config.yaml or ~/.config/pentoolkit/config.yaml
Format: YAML with environment variable support
Structure: Per-module configuration sections
Key Configuration Sections
global:
  default_timeout: 30
  default_threads: 40

nmap:
  scan_types:
    default: "-sV"
    aggressive: "-A -sV -O"
    stealth: "-sS -sV -f -T2"

ssl:
  default_port: 443
  additional_ports: [8443, 8080, 9443]

web_recon:
  wordlists:
    - "/usr/share/wordlists/dirb/common.txt"
  default_extensions: "php,html,htm,asp"

security:
  safe_mode: false
  allowed_networks:
    - "10.0.0.0/8"
    - "192.168.0.0/16"
4. Command Line Interface
Basic Usage Examples
# Basic scan with all modules
pentoolkit scan run target.com

# Custom module selection
pentoolkit scan run target.com --modules nmap,ssl,web_recon

# Advanced nmap options
pentoolkit scan run target.com --scan-type aggressive --ports 1-1000

# Interactive guided scan
pentoolkit scan interactive

# View scan history
pentoolkit results list

# Generate summary report
pentoolkit results show 1
CLI Command Structure
Main Groups: scan, results, config, admin
Rich UI: Progress bars, colored output, tables
User Safety: Confirmation prompts for external scans
5. Internal Architecture Flow
Execution Flow Diagram
The system follows this execution pattern:

CLI Input → User runs command with parameters
Validation → Target and options validated
Configuration → Load config, show scan preview
User Confirmation → Security prompt for external targets
Database Logging → Create scan record in SQLite
Module Orchestration → Sequential execution of selected modules
Result Collection → Gather outputs from all modules
Report Generation → JSON, HTML, and raw outputs created
Database Update → Mark scan complete with results path
Summary Display → Show key findings to user
Module Architecture
Each scanner module follows this pattern:

def scan(target: str, **kwargs) -> dict:
    # 1. Load configuration
    config = get_config()
    
    # 2. Validate target against security rules
    if not config.validate_target_network(target):
        return None
    
    # 3. Execute scanning logic
    results = perform_scan(target)
    
    # 4. Generate reports
    report.save_report(results, target, "module_name")
    report.save_report_html(results, target, "module_name")
    
    # 5. Display results
    print_results_table(results)
    
    return results
6. Core Modules Breakdown
Nmap Scanner (nmap_scanner.py)
Purpose: Network port scanning and service detection
Tools: python-nmap library + raw nmap commands
Features:
Multiple scan types (stealth, aggressive, discovery)
Service version detection
NSE script support
Raw XML output preservation
Output: List of open ports with service details
SSL Scanner (ssl_scanner.py)
Purpose: SSL/TLS security analysis
Features:
Certificate validation and expiry checking
Cipher suite security scoring
TLS version analysis
Multiple port scanning
Chain length detection
Security Analysis: Weak cipher detection, security scoring
Output: Comprehensive SSL security report
Web Reconnaissance (web_recon.py)
Purpose: Directory and file discovery
Tool: ffuf (Fast web fuzzer)
Features:
Configurable wordlists
Multi-threaded scanning
Custom extensions
Response filtering
Output: Discovered URLs with status codes
Additional Modules
Whois Lookup: Domain registration information
WAF Detection: Identify web application firewalls
7. Database & Tracking System
SQLite Database (pentoolkit_scans.db)
-- Scan tracking table
CREATE TABLE scans (
    id INTEGER PRIMARY KEY,
    target TEXT NOT NULL,
    modules TEXT NOT NULL,
    status TEXT NOT NULL,  -- running, completed, failed
    start_time TEXT NOT NULL,
    end_time TEXT,
    results_path TEXT
);

-- Individual module results (planned)
CREATE TABLE scan_results (
    scan_id INTEGER,
    module TEXT NOT NULL,
    result_data TEXT NOT NULL
);
Scan Lifecycle
Start: Insert record with status='running'
Progress: Track individual module execution
Complete: Update with status='completed' and results_path
Query: List recent scans, search by target
8. Report Generation System
Output Formats
JSON Reports: Machine-readable structured data
HTML Reports: Human-friendly visual reports
Raw Output: Original tool output (XML, text)
Aggregated Summary: Combined multi-module reports
Report File Naming
reports/
├── target_com_nmap_20241225_143022_123.json
├── target_com_nmap_20241225_143022_123.html
├── target_com_ssl_20241225_143055_456.json
├── target_com_ssl_20241225_143055_456.html
└── target_com_summary_20241225_143100_789.html
HTML Report Features
Executive Summary: Security score, key findings
Detailed Tables: Port listings, SSL analysis
Visual Design: Professional styling with color coding
Responsive Layout: Works on mobile and desktop
9. Security & Safety Features
Network Validation
Allowed Networks: Configurable IP ranges
Safe Mode: Prevents accidental external scanning
User Confirmation: Prompts for external targets
Input Validation
Target Sanitization: Clean hostnames and IPs
File Path Safety: Prevent directory traversal
Command Injection Protection: Use proper subprocess handling
10. Usage Examples & Demos
Typical Workflow
# 1. Setup
pentoolkit config create

# 2. Quick scan
pentoolkit scan run scanme.nmap.org

# 3. Full assessment
pentoolkit scan run target.com --modules all --scan-type aggressive

# 4. Review results
pentoolkit results list
pentoolkit results show 1

# 5. Open HTML report
pentoolkit results dashboard
Team Integration
Batch Scanning: Multiple targets from file
JSON Output: Machine-readable for automation
Report Sharing: HTML reports for stakeholders
History Tracking: All scans logged with timestamps
11. Key Benefits for Team
For Penetration Testers
Automated Reconnaissance: Consistent scan methodology
Professional Reports: Client-ready HTML output
Time Saving: Parallel execution of multiple tools
Audit Trail: Complete scan history and raw outputs
For Team Management
Standardization: Consistent tooling across team
Reporting: Executive summaries for stakeholders
Tracking: Database of all assessments
Customization: Configurable per engagement type
12. Future Improvements Needed
Immediate Priorities
Security Hardening: Fix default allow-all networks
Error Handling: Better module isolation
Parallel Execution: Run modules concurrently
Module Interface: Standardize module contracts
Medium Term
Plugin System: Easy module addition
Advanced Reporting: Custom templates
API Interface: REST API for integration
Team Collaboration: Shared scan database
This structure provides a comprehensive overview that your team can follow from installation through advanced usage, with clear examples and architectural understanding.