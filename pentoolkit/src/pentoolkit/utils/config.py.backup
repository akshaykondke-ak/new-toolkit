# pentoolkit/utils/config.py
import os
import yaml
from pathlib import Path
from typing import Dict, Any, List, Optional
from dataclasses import dataclass, field

# Determine the project root directory
PROJECT_ROOT = Path(__file__).parent.parent.parent.parent
DEFAULT_CONFIG_PATH = PROJECT_ROOT / "config.yaml"

@dataclass
class GlobalConfig:
    default_timeout: int = 30
    default_threads: int = 40

@dataclass 
class NmapConfig:
    default_args: str = "-sV"
    timeout: int = 300

@dataclass
class WebReconConfig:
    wordlists: List[str] = field(default_factory=lambda: [
        "/usr/share/wordlists/dirb/common.txt",
        "/home/admin-1/Desktop/common.txt"
    ])
    default_extensions: str = "php,html,htm"

class ConfigManager:
    def __init__(self, config_path: Optional[Path] = None):
        self.config_path = config_path or DEFAULT_CONFIG_PATH
        self._config_data: Dict[str, Any] = {}
        self.load_config()
    
    def load_config(self) -> None:
        if not self.config_path.exists():
            print(f"[!] Config file not found at {self.config_path}, using defaults")
            self._config_data = {}
            return
        
        try:
            with open(self.config_path, 'r') as f:
                self._config_data = yaml.safe_load(f) or {}
            print(f"[+] Loaded configuration from {self.config_path}")
        except Exception as e:
            print(f"[!] Error loading config: {e}")
            self._config_data = {}
    
    def get_section(self, section: str, default: Dict = None) -> Dict[str, Any]:
        return self._config_data.get(section, default or {})
    
    @property
    def web_recon_config(self) -> WebReconConfig:
        data = self.get_section("web_recon")
        config = WebReconConfig()
        if data:
            config.wordlists = data.get("wordlists", config.wordlists)
            config.default_extensions = data.get("default_extensions", config.default_extensions)
        return config
    
    def find_wordlist(self, wordlist_paths: List[str]) -> Optional[str]:
        for path in wordlist_paths:
            if os.path.exists(os.path.expanduser(path)):
                return path
        return None

# Global instance
config_manager = ConfigManager()

def get_config() -> ConfigManager:
    return config_manager

def reload_config() -> None:
    global config_manager
    config_manager.load_config()